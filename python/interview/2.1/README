寻找最小的k个数 

题目描述
	输入n个整数，输出其中最小的k个

分析与解法
 解法一

要求一个序列中最小的k个数，按照惯有的思维方式，则是先对这个序列从小到大排序，然后输出前面的最小的k个数。

至于选取什么的排序方法，我想你可能会第一时间想到快速排序（我们知道，快速排序平均所费时间为 n*logn ），然后再遍历序列中前k个元素输出即可。因此，总的时间复杂度： O（n * log n)+O(k)=O（n * log n） 。
解法二

咱们再进一步想想，题目没有要求最小的k个数有序，也没要求最后n-k个数有序。既然如此，就没有必要对所有元素进行排序。这时，咱们想到了用选择或交换排序，即：

1、遍历n个数，把最先遍历到的k个数存入到大小为k的数组中，假设它们即是最小的k个数；
2、对这k个数，利用选择或交换排序找到这k个元素中的最大值kmax（找最大值需要遍历这k个数，时间复杂度为 O（k） ）；
3、继续遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与kmax比较：如果 x < kmax ，用x替换kmax，并回到第二步重新找出k个元素的数组中最大元素kmax‘；如果 x >= kmax ，则继续遍历不更新数组。

每次遍历，更新或不更新数组的所用的时间为 O（k） 或 O（0） 。故整趟下来，时间复杂度为 n*O（k）=O（n*k） 。
解法三

更好的办法是维护容量为k的最大堆，原理跟解法二的方法相似：

    1、用容量为k的最大堆存储最先遍历到的k个数，同样假设它们即是最小的k个数；
    2、堆中元素是有序的，令k1<k2<...<kmax（kmax设为最大堆中的最大元素）
    3、遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与堆顶元素kmax比较：如果 x < kmax ，用x替换kmax，然后更新堆（用时logk）；否则不更新堆。

这样下来，总的时间复杂度: O（k+（n-k）*logk）=O（n*logk） 。此方法得益于堆中进行查找和更新的时间复杂度均为： O(logk) （若使用解法二：在数组中找出最大元素，时间复杂度： O（k）） 。
解法四

在《数据结构与算法分析--c语言描述》一书，第7章第7.7.6节中，阐述了一种在平均情况下，时间复杂度为 O（N） 的快速选择算法。如下述文字：

    选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样
        如果k <= |S1|，那么第k个最小元素必然在S1中。在这种情况下，返回QuickSelect(S1, k)。
        如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。
        否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，我们递归调用并返回QuickSelect(S2, k - |S1| - 1)。

此算法的平均运行时间为O(n)。 
